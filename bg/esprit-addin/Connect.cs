//--------------------------------------------------------------------------|
// This file was initially generated by the EspritAddInProjectWizard.       |
// Portions Copyright © 2011-2020 DP Technology Corp.                       |
//                                                                          |
// You have a royalty-free right to use, modify, reproduce and distribute   |
// this file (and/or any modified or compiled version of it) in any way     |
// you see fit, provided that you agree that DP Technology has no warranty  |
// obligations or liability whatsoever for this file or for the results of  |
// your use of it or any modified or compiled version of it you may make.   |
//--------------------------------------------------------------------------'

using DPTechnology.AnnexLibraries;
using DPTechnology.AnnexLibraries.EspritAnnex;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Windows.Forms;
using Esprit;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;

using Abuts.EspritAddIns.ESPRIT2025AddinProject.Properties;
using Abuts.EspritAddIns.ESPRIT2025AddinProject.Logging;


namespace Abuts.EspritAddIns.ESPRIT2025AddinProject
{

    [ClassInterface(ClassInterfaceType.None), ComVisible(true),
        Guid("1c4198bd-2143-470a-a041-93f2ebf4c904"),
        ProgId("ESPRIT2025AddinProject.Connect")]
    public class Connect : DPTechnology.AnnexLibraries.EspritAddIn
    {

        private static readonly HttpClient BackendHttp = new HttpClient(new HttpClientHandler
        {
            AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate,
            UseProxy = false,
        })
        {
            Timeout = TimeSpan.FromSeconds(20),
        };

        [DataContract]
        private class ApiResponseEnvelope<T>
        {
            [DataMember] public bool success { get; set; }
            [DataMember] public bool ok { get; set; }
            [DataMember] public T data { get; set; }
        }

        [DataContract]
        private class PendingItemsData
        {
            [DataMember] public PendingItem[] items { get; set; }
        }

        [DataContract]
        private class PendingItem
        {
            [DataMember] public string requestId { get; set; }
            [DataMember] public string filePath { get; set; }
            [DataMember] public string s3Key { get; set; }
            [DataMember] public string s3Url { get; set; }
        }

        private static void AddBridgeSecretHeader(HttpRequestMessage req)
        {
            var secret = (AppConfig.GetBridgeSecret() ?? string.Empty).Trim();
            if (!string.IsNullOrWhiteSpace(secret))
            {
                try { req.Headers.Remove("X-Bridge-Secret"); } catch { }
                req.Headers.Add("X-Bridge-Secret", secret);
            }
        }

        private static string BackendApiBase()
        {
            return (AppConfig.GetBackendUrl() ?? string.Empty).Trim().TrimEnd('/');
        }

        private static string SafeFileName(string value)
        {
            try
            {
                return Path.GetFileName(value ?? string.Empty);
            }
            catch
            {
                return value ?? string.Empty;
            }
        }

        private static void PurgeOldFiles(string dirPath, int days)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(dirPath)) return;
                if (!Directory.Exists(dirPath)) return;
                var thresholdUtc = DateTime.UtcNow.AddDays(-Math.Abs(days));
                foreach (var file in Directory.GetFiles(dirPath, "*", SearchOption.AllDirectories))
                {
                    try
                    {
                        var utc = File.GetLastWriteTimeUtc(file);
                        if (utc < thresholdUtc)
                        {
                            File.Delete(file);
                        }
                    }
                    catch { }
                }
            }
            catch { }
        }

        private static PendingItem[] FetchPendingNcItems()
        {
            try
            {
                var baseUrl = BackendApiBase();
                if (string.IsNullOrWhiteSpace(baseUrl)) return Array.Empty<PendingItem>();
                var url = baseUrl + "/bg/pending-nc";
                using (var req = new HttpRequestMessage(HttpMethod.Get, url))
                {
                    AddBridgeSecretHeader(req);
                    var resp = BackendHttp.SendAsync(req).GetAwaiter().GetResult();
                    var body = resp.Content.ReadAsStringAsync().GetAwaiter().GetResult() ?? string.Empty;
                    if (!resp.IsSuccessStatusCode)
                    {
                        AppLogger.Log($"Connect: pending-nc failed status={resp.StatusCode} body={body}");
                        return Array.Empty<PendingItem>();
                    }

                    try
                    {
                        using (var ms = new MemoryStream(Encoding.UTF8.GetBytes(body)))
                        {
                            var serializer = new DataContractJsonSerializer(typeof(ApiResponseEnvelope<PendingItemsData>));
                            var root = serializer.ReadObject(ms) as ApiResponseEnvelope<PendingItemsData>;
                            var items = root?.data?.items;
                            return items ?? Array.Empty<PendingItem>();
                        }
                    }
                    catch
                    {
                        return Array.Empty<PendingItem>();
                    }
                }
            }
            catch (Exception ex)
            {
                AppLogger.Log($"Connect: pending-nc error {ex.GetType().Name}:{ex.Message}");
                return Array.Empty<PendingItem>();
            }
        }

        private static bool DownloadSourceFileToFilledDir(string requestId, string filePath, string targetFullPath)
        {
            try
            {
                var baseUrl = BackendApiBase();
                if (string.IsNullOrWhiteSpace(baseUrl)) return false;

                var qs = new List<string>();
                qs.Add("sourceStep=2-filled");
                if (!string.IsNullOrWhiteSpace(requestId))
                {
                    qs.Add("requestId=" + Uri.EscapeDataString(requestId));
                }
                if (!string.IsNullOrWhiteSpace(filePath))
                {
                    qs.Add("filePath=" + Uri.EscapeDataString(filePath));
                }
                var url = baseUrl + "/bg/source-file?" + string.Join("&", qs);

                using (var req = new HttpRequestMessage(HttpMethod.Get, url))
                {
                    AddBridgeSecretHeader(req);
                    var resp = BackendHttp.SendAsync(req).GetAwaiter().GetResult();
                    if (!resp.IsSuccessStatusCode)
                    {
                        var body = string.Empty;
                        try { body = resp.Content.ReadAsStringAsync().GetAwaiter().GetResult(); } catch { }
                        AppLogger.Log($"Connect: source-file download failed status={resp.StatusCode} requestId={requestId} body={body}");
                        return false;
                    }
                    var bytes = resp.Content.ReadAsByteArrayAsync().GetAwaiter().GetResult();
                    var dir = Path.GetDirectoryName(targetFullPath);
                    if (!string.IsNullOrWhiteSpace(dir) && !Directory.Exists(dir))
                    {
                        Directory.CreateDirectory(dir);
                    }
                    File.WriteAllBytes(targetFullPath, bytes);
                    return true;
                }
            }
            catch (Exception ex)
            {
                AppLogger.Log($"Connect: source-file download error requestId={requestId} err={ex.GetType().Name}:{ex.Message}");
                return false;
            }
        }

        private static void RecoverPendingNcToQueue(EspritHttpServer httpServer)
        {
            try
            {
                if (httpServer == null) return;
                PurgeOldFiles(AppConfig.StorageFilledDirectory, 15);
                PurgeOldFiles(AppConfig.StorageNcDirectory, 15);

                var items = FetchPendingNcItems();
                if (items == null || items.Length == 0) return;

                foreach (var it in items)
                {
                    try
                    {
                        var rid = (it?.requestId ?? string.Empty).Trim();
                        var fp = (it?.filePath ?? string.Empty).Trim();
                        if (string.IsNullOrWhiteSpace(rid) || string.IsNullOrWhiteSpace(fp))
                        {
                            continue;
                        }

                        var safeName = SafeFileName(fp);
                        if (string.IsNullOrWhiteSpace(safeName))
                        {
                            continue;
                        }

                        var filledDir = AppConfig.StorageFilledDirectory;
                        if (!Directory.Exists(filledDir))
                        {
                            Directory.CreateDirectory(filledDir);
                        }
                        var localPath = Path.Combine(filledDir, safeName);
                        if (!File.Exists(localPath))
                        {
                            var ok = DownloadSourceFileToFilledDir(rid, fp, localPath);
                            if (!ok)
                            {
                                continue;
                            }
                        }

                        httpServer.EnqueueNcRequest(new NcGenerationRequest
                        {
                            RequestId = rid,
                            StlPath = localPath,
                            NcOutputPath = AppConfig.StorageNcDirectory,
                        });
                    }
                    catch { }
                }
            }
            catch { }
        }


        // Default Property Procedures should not need changes
        #region " Default Property Procedures "

        private DPTechnology.AnnexLibraries.IConnectionManager _ConnectionManager;
        protected override DPTechnology.AnnexLibraries.IConnectionManager ConnectionManager
        {
            get
            {
                if (_ConnectionManager == null)
                {
                    _ConnectionManager = new DPTechnology.AnnexLibraries.EspritAnnex.ConnectionManager();
                    _ConnectionManager.AddInConnect += _ConnectionManager_AddInConnect;
                    _ConnectionManager.AddInDisconnect += _ConnectionManager_AddInDisconnect;
                    _ConnectionManager.DocumentClosed += _ConnectionManager_DocumentClosed;
                    _ConnectionManager.DocumentInitialize += _ConnectionManager_DocumentInitialize;
                    _ConnectionManager.EspritApplicationShutdown += _ConnectionManager_EspritApplicationShutdown;
                }

                return _ConnectionManager;
            }
        }


        public override string Description
        {
            // To modify the AddInDescription go to the Resources tab in the project Properties.
            get { return Resources.AddInDescription; }
        }

        public override string FriendlyName
        {
            // To modify the AddInFriendlyName go to the Resources tab in the project Properties.
            get { return Resources.AddInFriendlyName; }
        }

        public override string Name
        {
            get { return System.Reflection.Assembly.GetExecutingAssembly().GetName().Name; }
        }

        public override System.Diagnostics.TraceLevel OutputWindowTraceLevel
        {
            // To modify the OutputWindowTraceLevel go to the Settings tab in the project Properties.
            get { return Settings.Default.OutputWindowTraceLevel; }
        }

        protected override Nullable<Int32> PreviousLanguage
        {
            get
            {
                Int32 returnValue;
                if (Int32.TryParse(Settings.Default.PreviousLanguage, out returnValue))
                    { return returnValue; }
                else
                    { return null; }
            }
            set
            {
                if (value.HasValue)
                {
                    Settings.Default.PreviousLanguage = value.Value.ToString();
                    Settings.Default.Save();
                }
            }
        }

        protected override System.Globalization.CultureInfo ResourcesCulture
        {
            get { return Resources.Culture; }
            set { Resources.Culture = value; }
        }

        #endregion


        private static Esprit.Application _espApp;
        private static Document _currentDocument;
        private static EspritHttpServer _httpServer;
        private static readonly _IApplicationEvents_AfterDocumentOpenEventHandler _afterDocumentOpenHandler = OnApplicationAfterDocumentOpen;
        private static readonly _IApplicationEvents_AfterNewDocumentOpenEventHandler _afterNewDocumentOpenHandler = OnApplicationAfterNewDocumentOpen;
        private static readonly _IApplicationEvents_AfterTemplateOpenEventHandler _afterTemplateOpenHandler = OnApplicationAfterTemplateOpen;
        public static Document CurrentDocument => _currentDocument ?? _espApp?.Document;
        public static void SetCurrentDocument(Document document)
        {
            _currentDocument = document;
        }

        private static void SetApplication(Esprit.Application application)
        {
            if (_espApp == application)
            {
                return;
            }

            if (_espApp != null)
            {
                ToggleApplicationEventHandlers(_espApp, false);
            }

            _espApp = application;

            if (_espApp != null)
            {
                SetCurrentDocument(_espApp.Document);
                ToggleApplicationEventHandlers(_espApp, true);
            }
        }

        private static void ToggleApplicationEventHandlers(Esprit.Application application, bool attach)
        {
            var eventType = typeof(_IApplicationEvents_Event);
            var afterDocumentOpen = new ComAwareEventInfo(eventType, nameof(_IApplicationEvents_Event.AfterDocumentOpen));
            var afterNewDocumentOpen = new ComAwareEventInfo(eventType, nameof(_IApplicationEvents_Event.AfterNewDocumentOpen));
            var afterTemplateOpen = new ComAwareEventInfo(eventType, nameof(_IApplicationEvents_Event.AfterTemplateOpen));

            if (attach)
            {
                afterDocumentOpen.AddEventHandler(application, _afterDocumentOpenHandler);
                afterNewDocumentOpen.AddEventHandler(application, _afterNewDocumentOpenHandler);
                afterTemplateOpen.AddEventHandler(application, _afterTemplateOpenHandler);
            }
            else
            {
                afterDocumentOpen.RemoveEventHandler(application, _afterDocumentOpenHandler);
                afterNewDocumentOpen.RemoveEventHandler(application, _afterNewDocumentOpenHandler);
                afterTemplateOpen.RemoveEventHandler(application, _afterTemplateOpenHandler);
            }
        }



        public static int _iCntOfCommands = 1;
        public Esprit.PMTab exTab;
        public Esprit.ProjectManager _pm;
        private AddInMainWindow _mainWindow;

        public static int _MyCookie;

        
        public void _ConnectionManager_AddInConnect(Esprit.Application espritApplication)
        {
            // If an Esprit.Application object property or variable is declared in your project you can assign it from here.
            //        
            // Since the EspritAddIn base class that is inherited handles the Document related Application events for you,
            // you should only need a WithEvents Esprit.Application for other non-Document related events, like AfterCommandRun.
            //        
            // This event can be removed if it does not need to be used (e.g. if you only need an Esprit.Document or Esprit.Document members).
            AppLogger.EnsureInitialized();

            SetApplication(espritApplication);
            _pm = _espApp.ProjectManager;

            // -------------------------
            // 1. Start HTTP Server for NC generation requests
            // -------------------------
            if (_httpServer == null)
            {
                _httpServer = new EspritHttpServer(espritApplication);
                _httpServer.Start();
            }

            try
            {
                var serverRef = _httpServer;
                Task.Run(() => RecoverPendingNcToQueue(serverRef));
            }
            catch { }

            // -------------------------
            // 2. Apply commands
            // -------------------------
            var EC = espritApplication.AddIn as EspritCommands.AddIn;
            _MyCookie = EC.GetCookie();

            
            //EC.OnCommand;
            EC.OnCommand += EC_OnCommand;

            // Show floating main window on launch
            string folderPath = AppConfig.StorageFilledDirectory;
            bool folderExists = Directory.Exists(folderPath);
            List<string> files = folderExists ? Directory.GetFiles(folderPath, "*.stl").ToList() : new List<string>();
            AppLogger.Log($"Connect: StorageFilledDirectory={folderPath}, exists={folderExists}, fileCount={files.Count}");

            if (_mainWindow == null || _mainWindow.IsDisposed)
            {
                _mainWindow = new AddInMainWindow();
                _mainWindow.FileRequested += HandleFileRequest;
            }

            _mainWindow.UpdateFiles(files);
            _mainWindow.ShowWindow();

        }


        private void EC_OnCommand(int Cookie, int UserId)
        {
            if (Cookie != _MyCookie)
                return;

            switch (UserId)
            {
                case 0:
                    DentalAddin.DentalPanel da = new DentalAddin.DentalPanel();
                    
                    exTab = ApplicationUtilities.AddProjectManagerTab(da);
                    ApplicationUtilities.TryActivateProjectManagerTab(exTab.HWND);
                    
                    da.InputFPointVal(0.25);
                    da.InputBPointVal(10.85);

                    // TODO : put your folder path as second argument of RepeatProcess constructor
                    // e.g.: RepeatProcess rp = new RepeatProcess(_espApp, @"C:\STLFiles");
                    // Event based processing, no need to run rp.Run()

                    break;
            }
        }

        public void _ConnectionManager_AddInDisconnect()
        {
            // Triggered when the Add-In disconnects because it was Unloaded from the Add-In Manager.
            // This means ESPRIT will remain running; otherwise only EspritApplicationShutdown is triggered.
            // This event procedure can be removed if it does not need to be used.
            if (exTab != null)
            {
                _pm?.PMTabs.Remove(exTab.HWND);
                exTab = null;
            }
            if (_mainWindow != null)
            {
                _mainWindow.FileRequested -= HandleFileRequest;
                _mainWindow.Close();
                _mainWindow = null;
            }
            if (_httpServer != null)
            {
                _httpServer.Stop();
                _httpServer.Dispose();
                _httpServer = null;
            }
            ReleaseApplicationEventHandlers();
        }

        private void HandleFileRequest(string filePath)
        {
            if (string.IsNullOrEmpty(filePath))
            {
                return;
            }

            try
            {
                new StlFileProcessor(_espApp).Process(filePath);
            }
            catch (Exception ex)
            {
                AppLogger.Log($"STL 처리 중 오류가 발생했습니다: {ex.Message}");
            }
        }

        public void _ConnectionManager_DocumentClosed(bool espritIsShuttingDown)
        {
            // Triggered after the Document has been closed.
            // The Boolean argument signals whether or not the Document was closed because ESPRIT is shutting down.
            // This event procedure can be removed if it does not need to be used.
            if (!espritIsShuttingDown)
            {
                SetCurrentDocument(null);
            }
        }

        public void _ConnectionManager_DocumentInitialize(Esprit.Document espritDocument, string fileName)
        {
            // 항상 최신 Document 포인터를 저장해 이후에도 null이 되지 않도록 유지
            SetCurrentDocument(espritDocument);

            // Triggered whenever the Document object has been re-initialized.
            //
            // If an Esprit.Document object property or variable is declared in your project you can assign it from here.
            // Procedures that apply to both New and existing ESPRIT files can then be called here also.
            //
            // Note that a Null filename (Nothing) indicates a New Document (AfterNewDocumentOpen event),
            // while a non-null filename could be an existing file (AfterDocumentOpen or AfterTemplateOpen event),
            // or could indicate connection to a running Esprit.Application that had a Document already open.
            // In the latter case the filename will not be null, but could be Empty to indicate an unsaved Document.
            //
            if (fileName == null) { return; }
            // Procedures that apply only when opening existing files (and not staring New ones) can be called here.
            //
            // This event procedure can be removed if it does not need to be used (but that is rarely the case).

        }

        public void _ConnectionManager_EspritApplicationShutdown()
        {
            // Triggered when the Add-In disconnects explicitly because ESPRIT is shutting down.
            // This event can be removed if it does not need to be used.
            SetApplication(null);
        }

        private static void OnApplicationAfterDocumentOpen(string fileName)
        {
            SetCurrentDocument(_espApp?.Document);
        }

        private static void OnApplicationAfterNewDocumentOpen()
        {
            SetCurrentDocument(_espApp?.Document);
        }

        private static void OnApplicationAfterTemplateOpen(string fileName)
        {
            SetCurrentDocument(_espApp?.Document);
        }

        private static void ReleaseApplicationEventHandlers()
        {
            if (_espApp != null)
            {
                ToggleApplicationEventHandlers(_espApp, false);
            }
        }


    }

}
